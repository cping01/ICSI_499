import kotlin.math.*

data class GPSPoint(val latitude: Double, val longitude: Double, val timestamp: Long)

data class Region(val name: String, val center: GPSPoint, val radius: Double) 
 
 

private fun calculateHeading(lat1: Double, lon1: Double, lat2: Double, lon2: Double): Double {
    val dlon = Math.toRadians(lon2 - lon1)
    val latHead1 = Math.toRadians(lat1)
    val latHead2 = Math.toRadians(lat2) 

    val y = sin(dlon) * cos(latHead2)
    val x = cos(latHead1) * sin(latHead2) - sin(latHead1) * cos(latHead2) * cos(dlon)
    return Math.toDegrees(atan2(y, x))
}

fun projectTrajectoryPrivacy(points: List<GPSPoint>):  List<GPSPoint>{
       // Scaling
       val scalingFactor = 1e6  
   
       // Differences
       val differences = points.zipWithNext { p1, p2 ->
           GPSPoint(
               (p2.latitude * scalingFactor - p1.latitude * scalingFactor) / scalingFactor,
               (p2.longitude * scalingFactor - p1.longitude * scalingFactor) / scalingFactor,
                p1.timestamp 
           )
       }
   
       // Return the key point and differences
       return  differences
}

private fun inferRegionFromGPS(points: List<GPSPoint>): Region {
    require(points.isNotEmpty()) { "Need at least one point to infer a region" }
    

      // Bounding Box Initialization
      var minLat = points[0].latitude
      var maxLat = points[0].latitude
      var minLon = points[0].longitude
      var maxLon = points[0].longitude
  
      for (point in points) {
          minLat = minOf(minLat, point.latitude)
          maxLat = maxOf(maxLat, point.latitude)
          minLon = minOf(minLon, point.longitude)
          maxLon = maxOf(maxLon, point.longitude)

        }
      
  
      val center = GPSPoint((minLat + maxLat) / 2, (minLon + maxLon) / 2, points[0].timestamp) 
      val initialRadius = 2000.0  // Start with an initial radius of 2 kilometers
  
      // Initialize the Region
      var region = Region("Inferred Region", center, initialRadius) 
    return region
}

private fun calculateRegion(currentRegion: Region, newPoint: GPSPoint, recentPoints: List<GPSPoint>): Region {
    // Distance from new point to region center
    val distance = haversine(currentRegion.center, newPoint)

    // Simple Expansion Logic
    if (distance > currentRegion.radius * (1 + 0.2)) { 
        // Point is outside (with buffer), expand radius
        val newRadius = distance * 1.1 // Expand by 10%
        return Region(currentRegion.name, currentRegion.center, newRadius) 
    } else {
        // Optionally recalculate the center based on recent points
        val newCenter = calculateCenter(recentPoints + newPoint) 
        return Region(currentRegion.name, newCenter, currentRegion.radius) 
    }
}

// Helper Function to calculate center (replace with your logic)
private fun calculateCenter(points: List<GPSPoint>): GPSPoint {
    // You can implement averaging or a more sophisticated centroid calculation here
    val sumLat = points.sumOf { it.latitude }
    val sumLon = points.sumOf { it.longitude }
    val avgLat = sumLat / points.size
    val avgLon = sumLon / points.size
    return GPSPoint(avgLat, avgLon, points[0].timestamp) // Use timestamp from any point
}

private fun haversine(point1: GPSPoint, point2: GPSPoint): Double {
    val lat1 = Math.toRadians(point1.latitude)
    val lat2 = Math.toRadians(point2.latitude)
    val dlat = Math.toRadians(point2.latitude - point1.latitude)
    val dlon = Math.toRadians(point2.longitude - point1.longitude)

    val a = sin(dlat / 2).pow(2.0) +
            cos(lat1) * cos(lat2) *
            sin(dlon / 2).pow(2.0)

    val c = 2 * atan2(sqrt(a), sqrt(1 - a))

    val earthRadius = 6371.0 // Earth radius in kilometers
    return earthRadius * c * 1000 // Convert to meters
 
    }

     
    
    fun processGPSPoints(points: List<GPSPoint>): List<GPSPoint> {
    var lastInferenceTime = System.currentTimeMillis() 
    val recentPoints = mutableListOf<GPSPoint>() 
     val reInferenceInterval = 5 * 60 * 1000 
     var currentRegion: Region = inferRegionFromGPS(points) // Initial region inference 
    // val scalingFactor = 1e6 
     val projectedTrajectory = mutableListOf<GPSPoint>()
        for (point in points) {
            val currentTime = point.timestamp
    
            if (currentTime - lastInferenceTime >= reInferenceInterval) {
                // Recalculate the region
                currentRegion = inferRegionFromGPS(recentPoints) 
    
                // Reset for the next interval
                lastInferenceTime = currentTime 
                recentPoints.clear() 
            }
    
            recentPoints.add(point) 
    
            // Privacy-Preserving Projection
            val trajectoryDifferences = projectTrajectoryPrivacy(points) // Use the current region
    
            // Simulated LBS-side reconstruction (for analysis)
           // val keyPoint = trajectoryDifferences.firstOrNull()?.let { points[0].copy(latitude = points[0].latitude * scalingFactor, longitude = points[0].longitude * scalingFactor) } 
    
            // Add the region center as the initial point
            projectedTrajectory.add(currentRegion.center) 
    
            for (diff in trajectoryDifferences) {
                val newLat = projectedTrajectory.last().latitude + diff.latitude
                val newLon = projectedTrajectory.last().longitude + diff.longitude
                projectedTrajectory.add(GPSPoint(newLat, newLon, diff.timestamp))
            }
    
            // **Do something with 'keyPoint', 'trajectoryDifferences', and 'projectedTrajectory'** 
            
        }
        return projectedTrajectory
    }

    // Constants (you might want to adjust these)
const val MILES_PER_METER = 0.000621371 
const val SECONDS_PER_HOUR = 3600.0
const val SECONDS_PER_MINUTE = 60.0
const val SPEEDING_THRESHOLD_MPH = 80.0
const val SPEEDING_DURATION_SECONDS = 20
const val ACCELERATION_DECELERATION_THRESHOLD_MPH = 7.0
const val MILLISECONDS_PER_HOUR = 3600000.0
const val MILES_PER_KILOMETER = 1.0 / 1.60934

fun calculateMetrics(projectedTrajectory: List<GPSPoint>): TripMetrics {
    var totalDistance = 0.0 // Miles 
    var totalSpeed = 0.0 // Sum of speeds
    var maxSpeed = 0.0 // Miles per hour
    var tripStartTime = projectedTrajectory.firstOrNull()?.timestamp ?: 0L
    var tripEndTime = projectedTrajectory.lastOrNull()?.timestamp ?: 0L
    var speedingInstances = 0
    var hardBrakingInstances = 0
    var rapidAccelerationInstances = 0
    var inSpeedingState = false // For tracking speeding duration
    var validSegments = 0 // To count segments with non-zero time difference

    for (i in 1 until projectedTrajectory.size) {
        val point1 = projectedTrajectory[i - 1]
        val point2 = projectedTrajectory[i]

        val distanceMiles = haversine(point1, point2) * MILES_PER_METER // Convert meters to miles directly


        val timeDiffSeconds = (point2.timestamp - point1.timestamp) / 1000.0

        if (timeDiffSeconds != 0.0) {
            validSegments++
            val timeDiffHours = timeDiffSeconds / SECONDS_PER_HOUR // Conversion to hours
            val speedMph = distanceMiles / timeDiffHours
            totalSpeed += speedMph // Add speed to total speed
            maxSpeed = maxOf(maxSpeed, speedMph)

            // Speeding Logic
            if (speedMph > SPEEDING_THRESHOLD_MPH) {
                if (!inSpeedingState) {
                    inSpeedingState = true
                    speedingInstances++
                }
            } else {
                inSpeedingState = false
            }

            // Acceleration / Deceleration Logic
            if (i >= 2) {
                val prevSpeedMph = haversine(projectedTrajectory[i - 2], point1) * MILES_PER_METER / (timeDiffSeconds / SECONDS_PER_HOUR)
                val speedChangeMph = speedMph - prevSpeedMph

                if (speedChangeMph >= ACCELERATION_DECELERATION_THRESHOLD_MPH) {
                    rapidAccelerationInstances++
                } else if (speedChangeMph <= -ACCELERATION_DECELERATION_THRESHOLD_MPH) {
                    hardBrakingInstances++
                }
            }
        }

        totalDistance += distanceMiles // Update total distance
    }

    val tripDurationMinutes = (tripEndTime - tripStartTime) / 1000.0 / SECONDS_PER_MINUTE

    val averageSpeed = if (validSegments > 0) totalSpeed / validSegments else 0.0 // Calculate average speed

    return TripMetrics(
        averageSpeed = averageSpeed,
        topSpeed = maxSpeed,
        tripDuration = tripDurationMinutes,
        tripDistance = totalDistance,
        speedingInstances = speedingInstances,
        hardBrakingInstances = hardBrakingInstances,
        rapidAccelerationInstances = rapidAccelerationInstances
    )
}






data class TripMetrics(
    val averageSpeed: Double,
    val topSpeed: Double,
    val tripDuration: Double,
    val tripDistance: Double,
    val speedingInstances: Int,
    val hardBrakingInstances: Int,
    val rapidAccelerationInstances: Int
)


    



fun main() {

    val points = listOf(
        GPSPoint(49.9931740, 30.2978897, 1668624500000), 
        GPSPoint(49.9905254, 30.2917099, 1668624530000),
        GPSPoint(49.9863314, 30.2841568, 1668624565000), 
        GPSPoint(49.9803709, 30.2748871, 1668624600000), 
        GPSPoint(49.9726432, 30.2608109, 1668624650000), 
        GPSPoint(49.9611597, 30.2402115, 1668624700000), 
        GPSPoint(49.9545334, 30.2288818, 1668624730000), 
        GPSPoint(49.9461388, 30.2175522, 1668624790000), 
        GPSPoint(49.9406152, 30.2106857, 1668624830000),
        GPSPoint(49.9406152, 30.2089691, 1668624840000), 
        GPSPoint(49.9399523, 30.2082825, 1668624850000), 
        GPSPoint(49.9399523, 30.2048492, 1668624870000),
        GPSPoint(49.9406152, 30.2021027, 1668624890000), 
        GPSPoint(49.9408361, 30.1996994, 1668624900000), 
        GPSPoint(49.9412780, 30.1972961, 1668624915000) 
    //     GPSPoint(49.9408361, 30.1952362, 1668624930000), 
    //     GPSPoint(49.9397314, 30.1928329, 1668624950000), 
    //     GPSPoint(49.9390685, 30.1890564, 1668624980000), 
    //     GPSPoint(49.9384056, 30.1852798, 1668625010000), 
    //     GPSPoint(49.9364168, 30.1852798, 1668625050000), 
    //     GPSPoint(49.9348700, 30.1859665, 1668625080000),  
    //     GPSPoint(49.9313341, 30.1883698, 1668625120000),  
    //     GPSPoint(49.9249247, 30.1883698, 1668625180000),  
    //     GPSPoint(49.9205040, 30.1907730, 1668625220000), 
    //     GPSPoint(49.9129878, 30.1869965, 1668625280000), 
    //     GPSPoint(49.9074604, 30.1849365, 1668625310000),  
    //     GPSPoint(49.8979518, 30.1804733, 1668625360000),  
    //     GPSPoint(49.8884413, 30.1766968, 1668625400000), 
    //     GPSPoint(49.8756103, 30.1691437, 1668625480000),  
    //     GPSPoint(49.8596774, 30.1636505, 1668625560000), 
    //     GPSPoint(49.8512662, 30.1588440, 1668625610000),  
    //     GPSPoint(49.8393110, 30.1595306, 1668625670000), 
    //     GPSPoint(49.8313392, 30.1684570, 1668625720000),  
    //     GPSPoint(49.8229231, 30.1794434, 1668625790000), 
    //     GPSPoint(49.8100747, 30.1897430, 1668625870000),  
    //     GPSPoint(49.8012117, 30.1993561, 1668625930000), 
    //     GPSPoint(49.7927904, 30.2014160, 1668625960000),  
    //     GPSPoint(49.7856976, 30.2000427, 1668625990000), 
    //     GPSPoint(49.7768301, 30.2000427, 1668626040000), 
    //     GPSPoint(49.7675176, 30.2000427, 1668626090000), 
    //     GPSPoint(49.7599775, 30.2000427, 1668626130000), 
    //     GPSPoint(49.7488871, 30.1993561, 1668626180000), 
    //     GPSPoint(49.7382379, 30.1979828, 1668626230000), 
    //     GPSPoint(49.7311371, 30.1966095, 1668626270000), 
    //     GPSPoint(49.7013913, 30.1972961, 1668626400000), 
    //       GPSPoint(49.6694054, 30.1890564, 1668626500000),  
    // GPSPoint(49.6587388, 30.1904297, 1668626540000), 
    // GPSPoint(49.6511818, 30.1883698, 1668626580000),  
    // GPSPoint(49.6409558, 30.1842499, 1668626640000),  
    // GPSPoint(49.6333961, 30.1835632, 1668626670000),  
    // GPSPoint(49.6249456, 30.1808167, 1668626710000),  
    // GPSPoint(49.6187180, 30.1808167, 1668626740000), 
    // GPSPoint(49.6129345, 30.1794434, 1668626770000),  
    // GPSPoint(49.6071504, 30.1787567, 1668626800000),   
    // GPSPoint(49.5942447, 30.1753235, 1668626860000), 
    // GPSPoint(49.5817809, 30.1746368, 1668626910000),  
    // GPSPoint(49.5728761, 30.1746368, 1668626950000), 
    // GPSPoint(49.5648605, 30.1725769, 1668627000000), 
    // GPSPoint(49.5555073, 30.1725769, 1668627060000)
) 


    // Region Inference
    val inferredRegion = inferRegionFromGPS(points)

    val projectedTrajectory = processGPSPoints(points)
    val tripMetrics = calculateMetrics(projectedTrajectory)




    // Print the inferred region
    println("Inferred Region: $inferredRegion") 
    
    // Analysis using the projected trajectory
    for (i in 0 until points.size - 1) {
        val point1 = points[i]
        val point2 = points[i + 1]

        // Original trajectory analysis
        val distance = haversine(point1, point2)
        val timeDifference = point2.timestamp - point1.timestamp
        val originalHeading = calculateHeading(point1.latitude, point1.longitude, point2.latitude, point2.longitude) 

        println("Original Trajectory Segment:")
        println("Point 1: $point1")
        println("Point 2: $point2")
        println("Distance: $distance meters")
        println("Time Difference: $timeDifference milliseconds")
        println("Heading: $originalHeading degrees\n") 
    }
     for (i in 0 until points.size - 2) {
         // Projected trajectory analysis (if projection is not the identity)
         if (projectedTrajectory[i] != points[i]) { // Check if projection actually changed the points 
             val projectedPoint1 = projectedTrajectory[i]
             val projectedPoint2 = projectedTrajectory[i + 1]

            val projectedDistance = haversine(projectedPoint1, projectedPoint2)
             val projectedTimeDifference = projectedPoint2.timestamp - projectedPoint1.timestamp 
             val projectedHeading = calculateHeading(projectedPoint1.latitude, projectedPoint1.longitude, projectedPoint2.latitude, projectedPoint2.longitude) 

             println("Projected Trajectory Segment:")
           println("Point 1: $projectedPoint1")
            println("Point 2: $projectedPoint2")
            println("Distance: $projectedDistance meters")
            println("Time Difference: $projectedTimeDifference milliseconds")
            println("Heading: $projectedHeading degrees\n") 

       }
     }    
     
     println("Trip Summary:")
     println("Average Speed: ${tripMetrics.averageSpeed} mph")
     println("Top Speed: ${tripMetrics.topSpeed} mph")
     println("Trip Duration: ${tripMetrics.tripDuration} minutes") 
     println("Trip Distance: ${tripMetrics.tripDistance} miles") 
     println("Speeding Instances: ${tripMetrics.speedingInstances}")
     println("Hard Braking Instances: ${tripMetrics.hardBrakingInstances}")
     println("Rapid Acceleration Instances: ${tripMetrics.rapidAccelerationInstances}")




}
